// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/ggsomnoev/sumup-notification-task/internal/notification/consumer/service"
	"github.com/ggsomnoev/sumup-notification-task/internal/notification/model"
	"github.com/google/uuid"
)

type FakeStore struct {
	AddMessageStub        func(context.Context, model.Message) error
	addMessageMutex       sync.RWMutex
	addMessageArgsForCall []struct {
		arg1 context.Context
		arg2 model.Message
	}
	addMessageReturns struct {
		result1 error
	}
	addMessageReturnsOnCall map[int]struct {
		result1 error
	}
	MarkCompletedStub        func(context.Context, uuid.UUID) error
	markCompletedMutex       sync.RWMutex
	markCompletedArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	markCompletedReturns struct {
		result1 error
	}
	markCompletedReturnsOnCall map[int]struct {
		result1 error
	}
	MessageExistsStub        func(context.Context, uuid.UUID) (bool, error)
	messageExistsMutex       sync.RWMutex
	messageExistsArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	messageExistsReturns struct {
		result1 bool
		result2 error
	}
	messageExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RunInAtomicallyStub        func(context.Context, func(context.Context) error) error
	runInAtomicallyMutex       sync.RWMutex
	runInAtomicallyArgsForCall []struct {
		arg1 context.Context
		arg2 func(context.Context) error
	}
	runInAtomicallyReturns struct {
		result1 error
	}
	runInAtomicallyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStore) AddMessage(arg1 context.Context, arg2 model.Message) error {
	fake.addMessageMutex.Lock()
	ret, specificReturn := fake.addMessageReturnsOnCall[len(fake.addMessageArgsForCall)]
	fake.addMessageArgsForCall = append(fake.addMessageArgsForCall, struct {
		arg1 context.Context
		arg2 model.Message
	}{arg1, arg2})
	stub := fake.AddMessageStub
	fakeReturns := fake.addMessageReturns
	fake.recordInvocation("AddMessage", []interface{}{arg1, arg2})
	fake.addMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStore) AddMessageCallCount() int {
	fake.addMessageMutex.RLock()
	defer fake.addMessageMutex.RUnlock()
	return len(fake.addMessageArgsForCall)
}

func (fake *FakeStore) AddMessageCalls(stub func(context.Context, model.Message) error) {
	fake.addMessageMutex.Lock()
	defer fake.addMessageMutex.Unlock()
	fake.AddMessageStub = stub
}

func (fake *FakeStore) AddMessageArgsForCall(i int) (context.Context, model.Message) {
	fake.addMessageMutex.RLock()
	defer fake.addMessageMutex.RUnlock()
	argsForCall := fake.addMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) AddMessageReturns(result1 error) {
	fake.addMessageMutex.Lock()
	defer fake.addMessageMutex.Unlock()
	fake.AddMessageStub = nil
	fake.addMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) AddMessageReturnsOnCall(i int, result1 error) {
	fake.addMessageMutex.Lock()
	defer fake.addMessageMutex.Unlock()
	fake.AddMessageStub = nil
	if fake.addMessageReturnsOnCall == nil {
		fake.addMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) MarkCompleted(arg1 context.Context, arg2 uuid.UUID) error {
	fake.markCompletedMutex.Lock()
	ret, specificReturn := fake.markCompletedReturnsOnCall[len(fake.markCompletedArgsForCall)]
	fake.markCompletedArgsForCall = append(fake.markCompletedArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.MarkCompletedStub
	fakeReturns := fake.markCompletedReturns
	fake.recordInvocation("MarkCompleted", []interface{}{arg1, arg2})
	fake.markCompletedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStore) MarkCompletedCallCount() int {
	fake.markCompletedMutex.RLock()
	defer fake.markCompletedMutex.RUnlock()
	return len(fake.markCompletedArgsForCall)
}

func (fake *FakeStore) MarkCompletedCalls(stub func(context.Context, uuid.UUID) error) {
	fake.markCompletedMutex.Lock()
	defer fake.markCompletedMutex.Unlock()
	fake.MarkCompletedStub = stub
}

func (fake *FakeStore) MarkCompletedArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.markCompletedMutex.RLock()
	defer fake.markCompletedMutex.RUnlock()
	argsForCall := fake.markCompletedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) MarkCompletedReturns(result1 error) {
	fake.markCompletedMutex.Lock()
	defer fake.markCompletedMutex.Unlock()
	fake.MarkCompletedStub = nil
	fake.markCompletedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) MarkCompletedReturnsOnCall(i int, result1 error) {
	fake.markCompletedMutex.Lock()
	defer fake.markCompletedMutex.Unlock()
	fake.MarkCompletedStub = nil
	if fake.markCompletedReturnsOnCall == nil {
		fake.markCompletedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markCompletedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) MessageExists(arg1 context.Context, arg2 uuid.UUID) (bool, error) {
	fake.messageExistsMutex.Lock()
	ret, specificReturn := fake.messageExistsReturnsOnCall[len(fake.messageExistsArgsForCall)]
	fake.messageExistsArgsForCall = append(fake.messageExistsArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.MessageExistsStub
	fakeReturns := fake.messageExistsReturns
	fake.recordInvocation("MessageExists", []interface{}{arg1, arg2})
	fake.messageExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) MessageExistsCallCount() int {
	fake.messageExistsMutex.RLock()
	defer fake.messageExistsMutex.RUnlock()
	return len(fake.messageExistsArgsForCall)
}

func (fake *FakeStore) MessageExistsCalls(stub func(context.Context, uuid.UUID) (bool, error)) {
	fake.messageExistsMutex.Lock()
	defer fake.messageExistsMutex.Unlock()
	fake.MessageExistsStub = stub
}

func (fake *FakeStore) MessageExistsArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.messageExistsMutex.RLock()
	defer fake.messageExistsMutex.RUnlock()
	argsForCall := fake.messageExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) MessageExistsReturns(result1 bool, result2 error) {
	fake.messageExistsMutex.Lock()
	defer fake.messageExistsMutex.Unlock()
	fake.MessageExistsStub = nil
	fake.messageExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) MessageExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.messageExistsMutex.Lock()
	defer fake.messageExistsMutex.Unlock()
	fake.MessageExistsStub = nil
	if fake.messageExistsReturnsOnCall == nil {
		fake.messageExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.messageExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) RunInAtomically(arg1 context.Context, arg2 func(context.Context) error) error {
	fake.runInAtomicallyMutex.Lock()
	ret, specificReturn := fake.runInAtomicallyReturnsOnCall[len(fake.runInAtomicallyArgsForCall)]
	fake.runInAtomicallyArgsForCall = append(fake.runInAtomicallyArgsForCall, struct {
		arg1 context.Context
		arg2 func(context.Context) error
	}{arg1, arg2})
	stub := fake.RunInAtomicallyStub
	fakeReturns := fake.runInAtomicallyReturns
	fake.recordInvocation("RunInAtomically", []interface{}{arg1, arg2})
	fake.runInAtomicallyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStore) RunInAtomicallyCallCount() int {
	fake.runInAtomicallyMutex.RLock()
	defer fake.runInAtomicallyMutex.RUnlock()
	return len(fake.runInAtomicallyArgsForCall)
}

func (fake *FakeStore) RunInAtomicallyCalls(stub func(context.Context, func(context.Context) error) error) {
	fake.runInAtomicallyMutex.Lock()
	defer fake.runInAtomicallyMutex.Unlock()
	fake.RunInAtomicallyStub = stub
}

func (fake *FakeStore) RunInAtomicallyArgsForCall(i int) (context.Context, func(context.Context) error) {
	fake.runInAtomicallyMutex.RLock()
	defer fake.runInAtomicallyMutex.RUnlock()
	argsForCall := fake.runInAtomicallyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) RunInAtomicallyReturns(result1 error) {
	fake.runInAtomicallyMutex.Lock()
	defer fake.runInAtomicallyMutex.Unlock()
	fake.RunInAtomicallyStub = nil
	fake.runInAtomicallyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) RunInAtomicallyReturnsOnCall(i int, result1 error) {
	fake.runInAtomicallyMutex.Lock()
	defer fake.runInAtomicallyMutex.Unlock()
	fake.RunInAtomicallyStub = nil
	if fake.runInAtomicallyReturnsOnCall == nil {
		fake.runInAtomicallyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runInAtomicallyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMessageMutex.RLock()
	defer fake.addMessageMutex.RUnlock()
	fake.markCompletedMutex.RLock()
	defer fake.markCompletedMutex.RUnlock()
	fake.messageExistsMutex.RLock()
	defer fake.messageExistsMutex.RUnlock()
	fake.runInAtomicallyMutex.RLock()
	defer fake.runInAtomicallyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.Store = new(FakeStore)
